<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>背包问题</title>
      <link href="2020/09/30/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>2020/09/30/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="背包问题">背包问题</h2><p>​<strong>给定一组物品，每种物品都有自己的重量和价值，现有一个背包，能承受的重量有限，在受限制的重量下，去取若干物品使总价值最大。</strong></p><h3 id="可拆分背包问题">可拆分背包问题</h3><pre><code>有$N$件物品和一个容积为$V$的背包。每件物品具有体积$c_i$和价值$w_i$。每件物品可以**分割成任意大小**后放入背包，且单位价值体积不变。该背包中最多可以放入的物品总价值为多少？</code></pre><p>​我们总是优先挑选<strong>单位体积内价值较高</strong>的物品放入背包内，所以对于每种物品，先计算其价值对体积的比值（性价比）$r_i=\frac{w_i}{c_i}$，之后对$r_i$进行排序后优先选择性价比较高的物品即可。</p><p>​可拆分背包问题作为一种较为简单的背包，正是由于其可拆分的性质，所以能够使用贪心轻易地解决。</p><h3 id="01背包问题">01背包问题</h3><p>​        <a href="https://www.luogu.com.cn/problem/P1060">洛谷P1060 开心的金明</a></p><p>​        <a href="https://www.luogu.com.cn/problem/P1048">洛谷P1048 采药</a></p><p>​当前有$N$件物品和一个容积为$V$的背包。已知第i件物品的体积是$c_i$，价值是$w_i$。每种物品有且仅有一件，并且<strong>体积不可分割</strong>，只能选择<strong>放入或者不放入</strong>背包。现在需要选出若干件物品，在重量之和不超过V的条件下，使得总价值尽可能大。</p><p>算性价比?</p><p>反例：</p><table><thead><tr><th>$c_i$</th><th>$w_i $</th><th>性价比</th></tr></thead><tbody><tr><td>4</td><td>8</td><td>2</td></tr><tr><td>3</td><td>5</td><td>$\frac{5}{3}$</td></tr><tr><td>3</td><td>4</td><td>$\frac{4}{3}$</td></tr></tbody></table><p>$V=6$</p><p>暴搜？</p><p>放或不放 $O(2^n)$</p><p><strong>动态规划：</strong></p><p>状态：前$i$个物品，总重量不超过$j$的前提下。所获得的最大价值为$dp[i][j]$。</p><p>转移方程：<br>$$<br>j&lt;c_i, dp[i][j]=dp[i-1][j]<br>$$<br>$$<br>c_i\leqslant j, dp[i][j]=max(dp[i-1][j],dp[i][j-c_i]+w_i)<br>$$</p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= c[i]) &#123;</span><br><span class="line">            dp[i][j] = max(dp[i - <span class="number">1</span>][j - c[i]] + w[i], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化：转移时第一维只与<code>i-1</code>和<code>i</code>有关，因此我们可以将dp数组压缩</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][V];</span><br></pre></td></tr></table></figure><h3 id="多重背包问题">多重背包问题</h3><p>​<a href="https://www.luogu.com.cn/problem/P1776">洛谷P1776 宝物筛选</a></p><p>​有$N$种物品，第$i$种物品的体积是$c_i$，价值是$w_i$，每种物品的<strong>数量都是有限的</strong>，为$n_i$。现有容量为$V$的背包，请你放入若干物品，在总体积不超过$V$的条件下，使总价值尽可能大。</p><p>解法一：</p><p>将$N$种物品逐个拆分，得到$\sum{n_i}$个独立物品后用01背包解决。$O(V\sum{n_i})$</p><p>解法二：</p><p>在转移的过程中枚举第$i$个物品选取的数量$k$，和01背包的思想一样。<br>$$<br>dp[i][j]=max(dp[i][j],dp[i-1][j-k<em>c_i]+k</em>w_i),0\leqslant k\leqslant n_i<br>$$<br>复杂度$O(V\sum{n_i})$</p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n[i]; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= c[i] * k) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j - c[i] * k] + w[i] * k, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这份代码和01背包相比不再有<code>else</code>部分了，因为<code>k=0</code>的时候<code>dp[i][j]=max(dp[i-1][j],dp[i][j])</code>，相当于01背包的<code>else</code>部分。</p><p>优化：</p><p>和01背包一样，由于转移方程只用到<code>i</code>和<code>i-1</code>，可以转成滚动数组，但由于<code>dp[i][j]</code>依赖初始值，所以在每次<code>j</code>循环开始之前一定要</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp[flag],<span class="number">0</span>,<span class="keyword">sizeof</span>(dp[flag]));</span><br></pre></td></tr></table></figure><h3 id="完全背包问题">完全背包问题</h3><pre><code>[洛谷P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)</code></pre><p>​当前有$N$种物品，第$i$种物品的体积是$c_i$，价值是$w_i$。每种物品的<strong>数量是无限的</strong>，可以任意选择若干件。现有容量为$V$的背包，请你放入若干物品，使总体积不超过$V$，并且总价值尽可能大。</p><p>​解法：虽然物品个数是无限的，但是实际上，由于背包容量有上限，每个物品最多选取的个数也是有限制的，这样可以转换成多重背包问题$n_i=\frac{V}{c_i}$，进而可以转换成01背包问题。</p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k * c[i] &lt;= j; k++) &#123;</span><br><span class="line">            dp[i][j] = max(dp[i - <span class="number">1</span>][j - c[i] * k] + w[i] * k, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间效率优化：</strong></p><p>我们可以注意到<br>$$<br>dp[i][j]=max(dp[i-1][j],dp[i-1][j-c_i]+w_i,dp[i-1][j-c_i<em>2]+w_i</em>2…)<br>$$<br>而<br>$$<br>dp[i][j-c_i]=max(dp[i-1][j-c_i],dp[i-1][j-c_i<em>2]+w_i,dp[i-1][j-c_i</em>3]+w_i*2…)<br>$$<br>也就是说，我们完全可以用<code>dp[i][j-c[i]]</code>的信息去更新<code>dp[i][j]</code>，而不用多此一举去枚举<code>k</code>了，转移可以直接变成如下<br>$$<br>dp[i][j]=max(dp[i-1][j],dp[i][j-c_i]+w[i])<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= v; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= c[i]) &#123;</span><br><span class="line">            dp[i][j] = max(dp[i][j - c[i]] + w[i], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背包问题的空间优化">背包问题的空间优化</h3><p>二维转一维</p><p>以01背包为例：</p><p>原来的滚动数组代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; c[i]) &#123;</span><br><span class="line">            dp[flag][j] = max(dp[<span class="number">1</span> - flag][j - c[i]] + w[i], dp[<span class="number">1</span> - flag][j]);    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[flag][j] = dp[<span class="number">1</span> - flag][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="number">1</span> - flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们把 <code>dp</code> 数组只开成一维表示体积，然后从大到小枚举体积，也就是从 $V$到$0$枚举，则当前引用的 <code>dp[j]</code>和<code>dp[j-c[i]]</code>仍然是计算第<code>i-1</code>件物品的结果，即二维状态下的<code>dp[1-flag][j]</code>, <code>dp[1-flag][j-c[i]]</code>,因为我们之前没有更新过<code>dp[1-flag][j]</code>,<code>dp[1-flag][j-c[i]]</code>的值。</p><p>故我们可以简化转移方程：<br>$$<br>dp[j]=max(dp[j-c_i]+w_i,dp[j])<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= c[i]; j--) &#123;</span><br><span class="line">        dp[j] = max(dp[j - c[i]] + w[i], dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，多重背包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n[i]; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= c[i] * k) &#123;</span><br><span class="line">                dp[j] = max(dp[j - c[i] * k] + w[i] * k, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全背包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = c[i]; j &lt;= v; j++) &#123;</span><br><span class="line">        dp[j] = max(dp[j - c[i]] + w[i], dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节省了一半空间。</p><h3 id="扩展——分组背包问题">扩展——分组背包问题</h3><p>​<a href="https://www.luogu.com.cn/problem/P1757">洛谷P1757 通天之分组背包</a></p><p>​当前有$N$种物品，第$i$种物品的体积是$c_i$，价值是$w_i$。每种物品有且仅有一件。**这些东西被分为$K$组，同组的物品不能同时放入背包。**现有容量为$V$的背包，请你放入若干物品，使总体积不超过$V$，并且总价值尽可能大。</p><p>解法：</p><p>在考虑最优解时，对于每一组内的物品有两种选择策略，要么选择组中的某一个物品放入背包，要么包内的任何一个物品都不选入背包。考虑到该策略与 01 背包的相似性，我们可以将<strong>一组物品</strong>抽象成单独的物品。首先使用朴素的 01 背包写法，用 <code>dp[i][j]</code> 表示枚举到第 $i$ 组物品时，背包体积不超过 $j$ 的最大价值和。</p><p>而与 01 背包不同的是，对于组内的每一个物品需要逐一枚举。</p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n[i]; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= c[i][k]) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - c[i][k]] + w[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><table><thead><tr><th>背包类型</th><th>每种物品数量</th><th>基本解法</th></tr></thead><tbody><tr><td>01背包</td><td>1个</td><td>动规，双循环选最大值</td></tr><tr><td>多重背包</td><td>若干个</td><td>在01的基础上枚举选择的数量或将物品拆分成独立物品后按01来做</td></tr><tr><td>完全背包</td><td>无限</td><td>算出可放物品最大数量后按多重背包做</td></tr></tbody></table><p>作业：洛谷</p>]]></content>
      
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/09/16/hello-world/"/>
      <url>2020/09/16/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="赵嘉熠的博客">赵嘉熠的博客</h3><h4 id="建站于2020-9">建站于2020.9</h4><h4 id="。・∀・-ノ">(。・∀・)ノ</h4><p><img src="http://zhaojiayibjea.gitee.io/zhaojiayipicture/BJEA_real.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
