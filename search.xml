<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>背包问题</title>
      <link href="2020/09/30/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>2020/09/30/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><strong>给定一组物品，每种物品都有自己的重量和价值，现有一个背包，能承受的重量有限，在受限制的重量下，去取若干物品使总价值最大。</strong></p><h3 id="可拆分背包问题"><a href="#可拆分背包问题" class="headerlink" title="可拆分背包问题"></a>可拆分背包问题</h3><p>有$N$件物品和一个容积为$V$的背包。每件物品具有体积$c_i$和价值$w_i$。每件物品可以<strong>分割成任意大小</strong>后放入背包，且单位价值体积不变。该背包中最多可以放入的物品总价值为多少？</p><p>我们总是优先挑选<strong>单位体积内价值较高</strong>的物品放入背包内，所以对于每种物品，先计算其价值对体积的比值（性价比）$r_i=\frac{w_i}{c_i}$，之后对$r_i$进行排序后优先选择性价比较高的物品即可。</p><p>可拆分背包问题作为一种较为简单的背包，正是由于其可拆分的性质，所以能够使用贪心轻易地解决。</p><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p>​        <a href="https://www.luogu.com.cn/problem/P1060">洛谷P1060 开心的金明</a></p><p>​        <a href="https://www.luogu.com.cn/problem/P1048">洛谷P1048 采药</a></p><p>当前有$N$件物品和一个容积为$V$的背包。已知第i件物品的体积是$c_i$，价值是$w_i$。每种物品有且仅有一件，并且<strong>体积不可分割</strong>，只能选择<strong>放入或者不放入</strong>背包。现在需要选出若干件物品，在重量之和不超过V的条件下，使得总价值尽可能大。</p><p>算性价比?</p><p>反例：</p><div class="table-container"><table><thead><tr><th>$c_i$</th><th>$w_i $</th><th>性价比</th></tr></thead><tbody><tr><td>4</td><td>8</td><td>2</td></tr><tr><td>3</td><td>5</td><td>$\frac{5}{3}$</td></tr><tr><td>3</td><td>4</td><td>$\frac{4}{3}$</td></tr></tbody></table></div><p>$V=6$</p><p>暴搜？</p><p>放或不放 $O(2^n)$</p><p><strong>动态规划：</strong></p><p>状态：前$i$个物品，总重量不超过$j$的前提下。所获得的最大价值为$dp[i][j]$。</p><p>转移方程：</p><script type="math/tex; mode=display">j<c_i, dp[i][j]=dp[i-1][j]</script><script type="math/tex; mode=display">c_i\leqslant j, dp[i][j]=max(dp[i-1][j],dp[i][j-c_i]+w_i)</script><p>核心代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">for (int i = 1; i <= N; ++i) &#123;    for (int j = 0; j <= V; ++j) &#123;        if(j >= c[i]) &#123;            dp[i][j] = max(dp[i - 1][j - c[i]] + w[i], dp[i - 1][j]);        &#125; else &#123;            dp[i][j] = dp[i - 1][j];        &#125;    &#125;&#125;</code></pre><p>优化：转移时第一维只与<code>i-1</code>和<code>i</code>有关，因此我们可以将dp数组压缩</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">int dp[2][V];</code></pre><h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><p>​        <a href="https://www.luogu.com.cn/problem/P1776">洛谷P1776 宝物筛选</a></p><p>有$N$种物品，第$i$种物品的体积是$c_i$，价值是$w_i$，每种物品的<strong>数量都是有限的</strong>，为$n_i$。现有容量为$V$的背包，请你放入若干物品，在总体积不超过$V$的条件下，使总价值尽可能大。</p><p>解法一：</p><p>将$N$种物品逐个拆分，得到$\sum{n_i}$个独立物品后用01背包解决。$O(V\sum{n_i})$</p><p>解法二：</p><p>在转移的过程中枚举第$i$个物品选取的数量$k$，和01背包的思想一样。</p><script type="math/tex; mode=display">dp[i][j]=max(dp[i][j],dp[i-1][j-k*c_i]+k*w_i),0\leqslant k\leqslant n_i</script><p>复杂度$O(V\sum{n_i})$</p><p> 核心代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">for (int i = 1; i <= N; i++) &#123;    for (int j = 0; j <= V; j++) &#123;        for (int k = 0; k <= n[i]; k++) &#123;            if (j >= c[i] * k) &#123;                dp[i][j] = max(dp[i - 1][j - c[i] * k] + w[i] * k, dp[i][j]);            &#125;        &#125;    &#125;&#125;</code></pre><p>这份代码和01背包相比不再有<code>else</code>部分了，因为<code>k=0</code>的时候<code>dp[i][j]=max(dp[i-1][j],dp[i][j])</code>，相当于01背包的<code>else</code>部分。</p><p>优化：</p><p>和01背包一样，由于转移方程只用到<code>i</code>和<code>i-1</code>，可以转成滚动数组，但由于<code>dp[i][j]</code>依赖初始值，所以在每次<code>j</code>循环开始之前一定要</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">memset(dp[flag],0,sizeof(dp[flag]));</code></pre><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p><a href="https://www.luogu.com.cn/problem/P1616">洛谷P1616 疯狂的采药</a></p><p>当前有$N$种物品，第$i$种物品的体积是$c_i$，价值是$w_i$。每种物品的<strong>数量是无限的</strong>，可以任意选择若干件。现有容量为$V$的背包，请你放入若干物品，使总体积不超过$V$，并且总价值尽可能大。</p><p>解法：虽然物品个数是无限的，但是实际上，由于背包容量有上限，每个物品最多选取的个数也是有限制的，这样可以转换成多重背包问题$n_i=\frac{V}{c_i}$，进而可以转换成01背包问题。</p><p>核心代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">for (int i = 1; i <= N; i++) &#123;    for (int j = 0; j <= V; j++) &#123;        for (int k = 0; k * c[i] <= j; k++) &#123;            dp[i][j] = max(dp[i - 1][j - c[i] * k] + w[i] * k, dp[i][j]);        &#125;    &#125;&#125;</code></pre><p><strong>时间效率优化：</strong></p><p>我们可以注意到</p><script type="math/tex; mode=display">dp[i][j]=max(dp[i-1][j],dp[i-1][j-c_i]+w_i,dp[i-1][j-c_i*2]+w_i*2...)</script><p>而</p><script type="math/tex; mode=display">dp[i][j-c_i]=max(dp[i-1][j-c_i],dp[i-1][j-c_i*2]+w_i,dp[i-1][j-c_i*3]+w_i*2...)</script><p>也就是说，我们完全可以用<code>dp[i][j-c[i]]</code>的信息去更新<code>dp[i][j]</code>，而不用多此一举去枚举<code>k</code>了，转移可以直接变成如下</p><script type="math/tex; mode=display">dp[i][j]=max(dp[i-1][j],dp[i][j-c_i]+w[i])</script><pre class=" language-lang-cpp"><code class="language-lang-cpp">for (int i = 1; i <= n; i++) &#123;    for (int j = 0; j <= v; j++) &#123;        if (j >= c[i]) &#123;            dp[i][j] = max(dp[i][j - c[i]] + w[i], dp[i - 1][j]);        &#125; else &#123;            dp[i][j] = dp[i - 1][j];        &#125;    &#125;&#125;</code></pre><h3 id="背包问题的空间优化"><a href="#背包问题的空间优化" class="headerlink" title="背包问题的空间优化"></a>背包问题的空间优化</h3><p>二维转一维</p><p>以01背包为例：</p><p>原来的滚动数组代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">int flag = 1;for (int i = 1; i <= N; i++) &#123;    for (int j = 0; j <= V; j++) &#123;        if (j > c[i]) &#123;            dp[flag][j] = max(dp[1 - flag][j - c[i]] + w[i], dp[1 - flag][j]);            &#125; else &#123;            dp[flag][j] = dp[1 - flag][j];        &#125;    &#125;    flag = 1 - flag;&#125;</code></pre><p>如果我们把 <code>dp</code> 数组只开成一维表示体积，然后从大到小枚举体积，也就是从 $V$到$0$枚举，则当前引用的 <code>dp[j]</code>和<code>dp[j-c[i]]</code>仍然是计算第<code>i-1</code>件物品的结果，即二维状态下的<code>dp[1-flag][j]</code>, <code>dp[1-flag][j-c[i]]</code>,因为我们之前没有更新过<code>dp[1-flag][j]</code>,<code>dp[1-flag][j-c[i]]</code>的值。</p><p>故我们可以简化转移方程：</p><script type="math/tex; mode=display">dp[j]=max(dp[j-c_i]+w_i,dp[j])</script><pre class=" language-lang-cpp"><code class="language-lang-cpp">for (int i = 1; i <= n; i++)&#123;    for (int j = v; j >= c[i]; j--) &#123;        dp[j] = max(dp[j - c[i]] + w[i], dp[j]);    &#125;&#125;</code></pre><p>同理，多重背包：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">for (int i = 1; i <= N; i++) &#123;    for (int j = V; j >= 0; j--) &#123;        for (int k = 1; k <= n[i]; k++) &#123;            if (j >= c[i] * k) &#123;                dp[j] = max(dp[j - c[i] * k] + w[i] * k, dp[j]);            &#125;        &#125;    &#125;&#125;</code></pre><p>完全背包：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">for (int i = 1; i <= n; i++) &#123;    for (int j = c[i]; j <= v; j++) &#123;        dp[j] = max(dp[j - c[i]] + w[i], dp[j]);    &#125;&#125;</code></pre><p>节省了一半空间。</p><h3 id="扩展——分组背包问题"><a href="#扩展——分组背包问题" class="headerlink" title="扩展——分组背包问题"></a>扩展——分组背包问题</h3><p><a href="https://www.luogu.com.cn/problem/P1757">洛谷P1757 通天之分组背包</a></p><p>当前有$N$种物品，第$i$种物品的体积是$c_i$，价值是$w_i$。每种物品有且仅有一件。<strong>这些东西被分为$K$组，同组的物品不能同时放入背包。</strong>现有容量为$V$的背包，请你放入若干物品，使总体积不超过$V$，并且总价值尽可能大。</p><p>解法：</p><p>在考虑最优解时，对于每一组内的物品有两种选择策略，要么选择组中的某一个物品放入背包，要么包内的任何一个物品都不选入背包。考虑到该策略与 01 背包的相似性，我们可以将<strong>一组物品</strong>抽象成单独的物品。首先使用朴素的 01 背包写法，用 <code>dp[i][j]</code> 表示枚举到第 $i$ 组物品时，背包体积不超过 $j$ 的最大价值和。</p><p>而与 01 背包不同的是，对于组内的每一个物品需要逐一枚举。</p><p>核心代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">for (int i = 1; i <= K; i++) &#123;    for (int j = 0; j <= V; j++) &#123;        dp[i][j] = dp[i - 1][j];        for (int k = 0; k < n[i]; k++) &#123;            if (j >= c[i][k]) &#123;                dp[i][j] = max(dp[i][j], dp[i - 1][j - c[i][k]] + w[i][k]);            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><div class="table-container"><table><thead><tr><th>背包类型</th><th>每种物品数量</th><th>基本解法</th></tr></thead><tbody><tr><td>01背包</td><td>1个</td><td>动规，双循环选最大值</td></tr><tr><td>多重背包</td><td>若干个</td><td>在01的基础上枚举选择的数量或将物品拆分成独立物品后按01来做</td></tr><tr><td>完全背包</td><td>无限</td><td>算出可放物品最大数量后按多重背包做</td></tr></tbody></table></div><p>作业：洛谷</p>]]></content>
      
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/09/16/hello-world/"/>
      <url>2020/09/16/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="赵嘉熠的博客"><a href="#赵嘉熠的博客" class="headerlink" title="赵嘉熠的博客"></a>赵嘉熠的博客</h3><h4 id="建站于2020-9"><a href="#建站于2020-9" class="headerlink" title="建站于2020.9"></a>建站于2020.9</h4><h4 id="。・∀・-ノ"><a href="#。・∀・-ノ" class="headerlink" title="(。・∀・)ノ"></a>(。・∀・)ノ</h4><p><img src="http://zhaojiayibjea.gitee.io/zhaojiayipicture/BJEA_real.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
